\chapter{Wstęp}
Dla prostoty i przejrzystości sprawozdania wykorzystane zostały oznaczenia pierwotnie wprowadzone w skrypcie z przedmiotu STP.

Zadane wartości:

$W1=50\%$

$G1_{\mathrm{pp}}=U_{\mathrm{pp}}=25+5=30$

$T=1s$ - okres próbkowania

Ograniczenia:

$0 \le G1(k) \le 100$

\chapter{Podpunkt 1}
Sprawdzenie możliwości sterowania i pomiaru w komunikacji ze stanowiskiem odbyło się poprzez wysłanie do stanowiska kilku różnych wartości sterowania i zaobserwowanie odpowiedniej odpowiedzi stanowiska oraz zmian w napływających danych.

Wartości sterowania w punkcie pracy zadane przez prowadzącego laboratoria to: $W_1=50\%$, $G_1=25+5=30$. Zgodnie z treścią zadania wartość $W_1$ nie była zmieniana, sterowanie odbywało się sygnałem $G_1$, zaś sygnał $T_1$ traktowany był jako sygnał wyjściowy. W dalszej części sprawozdania zamiennie będziemy używać oznaczeń $G_1$, $U$ na sygnał sterujący oraz oznaczeń $T_1$, $Y$ na sygnał wyjściowy.

Pomiar wartości temperatury w punkcie pracy odbył się zgodnie z poleceniem poprzez zadanie wartości sygnałów sterujących $W_1$, $G_1$, a następnie zarejestrowanie wartości sygnału $T_1$ po ustabilizowaniu się układu. Warto w tym momencie zauważyć, że ze względu na charakter układu i jego podatność na zakłócenia zaobserwowano drobne zmiany punktu pracy. Dlatego też w dalszych pracach za punkt pracy przyjęto średnią z trzech pomiarów, która wyniosła $T_1=\num{32,31}$.


\chapter{Podpunkt 2}
Na potrzeby wyznaczenia odpowiedzi skokowych wybrane zostały trzy różne wartości skoku $\triangle U = \{10, 20, 30\}$. Na rys. \ref{R1} zamieszczono wyznaczone odpowiedzi.

\begin{figure}[ht]
\centering
\input{images/steps}
\caption{Odpowiedź dla skoków z punktu pracy o $\triangle U = \{10, 20, 30\}$}
\label{R1}
\end{figure}

Obliczając wzmocnienie statyczne dla każdej z trzech odpowiedzi skokowych na podstawie wzoru:
\begin{equation}
 K=\frac{Y_{\mathrm{konc}}-Y_{\mathrm{pp}}}{\triangle U}
 \end{equation}
dostajemy $K_1=\num{0,275}$, $K_2=\num{0,281}$, $K_3=\num{0,2853}$.

Wyznaczone wzmocnienia są bardzo zbliżone dla różnych skoków, warto też zauważyć, że temperatura ani przed skokiem, ani po stabilizacji nie przyjmuje stałej wartości, a jedynie oscyluje w ograniczonym przedziale. Wynikająca z wyboru punktu pracy oraz punktu stabilizacji niepewność wyznaczonych wzmocnień wynosi ok. $\pm \num{0,01}$ (wyznaczona jako różnica między wartościami skrajnymi).

Charakterystykę obiektu można więc uznać w badanym zakresie za w dobrym przybliżeniu liniową. Otrzymane podczas optymalizacji w kolejnym podpunkcie wzmocnienie wyniosło $K_{\mathrm{mod}}=\num{0,285}$ i tą też wartość możemy ostatecznie przyjąć za wzmonienie statyczne procesu.


\chapter{Podpunkt 3}
Na potrzeby algorytmu DMC przekształcona została odpowiedź skokowa dla skoku z punktu pracy o $\triangle U = 10$. Do przekształcenia wykorzystany został wzór (\ref{step_norm}), zaś uzyskana odpowiedź skokowa została przedstawiona na rys. \ref{R2}. Kolejne wartości wyznaczonej odpowiedzi skokowej zadanego modelu zapisane są w pliku \verb+step_response.txt+.
\begin{equation}
S_i = \frac{S_i^0 - Y_{\mathrm{pp}}}{\triangle U} \textrm{, dla } i=1,\ldots
\label{step_norm}
\end{equation}
gdzie $S_i^0$ to kolejne wartości dyskretnej odpowiedzi skokowej procesu, $\triangle U$ to wartość skoku sygnału sterującego, zaś $S_i$ to kolejne wartości odpowiedzi skokowej wykorzystywanej później przez algorytm DMC.

\begin{figure}[ht]
\centering
\input{images/approximated_step_response}
\caption{Aproksymacja dla skoku z punktu pracy o $\triangle U = 10$}
\label{R2}
\end{figure}

\begin{figure}[ht]
\centering
\input{images/model_approximation2}
\caption{Porównanie aproksymacji z odpowiedzią rzeczywistą dla skoku z punktu pracy o $\triangle U = 10$}
\label{R3}
\end{figure}

Optymalizacja przeprowadzona została początkowo przy użyciu metody \verb+ga+ wykorzystującej algorytm genetyczny jednakże ze względu na otrzymywanie bardzo niestabilnych rozwiązań zastosowaliśmy ostatecznie metodę \verb+fmincon+ z parametrami początkowymi $[\num{0,5} ~ 20 ~ 25]$. Wartości parametrów początkowych zostały oszacowane na podstawie poprzednich wyników uzyskanych za pomocą algorytmu genetycznego. Funkcja ta została wykorzystana w pętli do optymalizacji parametrów $K$, $T_1$ oraz $T_2$ zaś parametr $T_{\mathrm{D}}$ był inkrementowany w kolejnych iteracjach pętli.

Ostatecznie najlepszy wynik otrzymany został dla $T_{\mathrm{D}}=26$, $K=\num{0.284889175853091}$, $T_1=\num{6.766718807934197e-11}$, $T_2=\num{92.458806630315240}$.

\chapter{Podpunkt 4}
Programy do symulacji cyfrowej algorytmów PID oraz DMC (w wersji analitycznej) dla symulowanego procesu umieszczone zostały odpowiednio w plikach \verb+PID.m+, \verb+DMC.m+, zaś w plikach \verb+PID_err.m+ oraz \verb+DMC_err.m+ umieszczono funkcje pomocnicze do obliczania wartości błędu.

\input{images/PID1}

\input{images/PID2}

\input{images/PIDsim_err_3527}

\input{images/DMC_err_3021_4}

Symulacja cyfrowego algorytmu PID odbywa się w oparciu o postać dyskretną
\begin{equation}
r_2 = \frac{K T_{\mathrm{d}}}{T_{\mathrm{s}}} \
r_1 = K \left( \frac{T_{\mathrm{s}}}{2 T_{\mathrm{i}}} - \frac{2 T_{\mathrm{d}}}{T_{\mathrm{s}}} - 1 \right) \
r_0 = K \left( 1 + \frac{T_{\mathrm{s}}}{2 T_{\mathrm{i}}} + \frac{T_{\mathrm{d}}}{T_{\mathrm{s}}} \right) \\
\label{r_t}
\end{equation}
\begin{equation}
\triangle U(k) = r_2 e(k-2) + r_1 e(k-1) + r_0 e(k)
\label{du}
\end{equation}
gdzie $e(k)=Y^{\mathrm{zad}}(k) - Y(k)$ to uchyb. We wzorach (\ref{du2}--\ref{upp}) sterowanie jest przycinane zgodnie z ograniczeniami, a następnie przesuwane do punktu pracy.

\begin{equation}
\triangle U(k) = 
\begin{cases}
-\triangle U^{\mathrm{max}} &\quad \textrm{gdy } \ \triangle U(k) \le -\triangle U^{\mathrm{max}} \\
\triangle U^{\mathrm{max}} &\quad \textrm{gdy } \ \triangle U(k) \ge \triangle U^{\mathrm{max}}  \\
\triangle U(k) &\quad \textrm{w p.p.}
\end{cases}
\label{du2}
\end{equation}

\begin{equation}
U(k) = \triangle U(k) + U(k-1)
\label{uk}
\end{equation}

\begin{equation}
U(k) = 
\begin{cases}
U^{\mathrm{min}} - U_{\mathrm{pp}} &\quad \textrm{gdy } \ U(k) \le U^{\mathrm{min}}-U_{\mathrm{pp}} \\
U^{\mathrm{max}}-U_{\mathrm{pp}} &\quad \textrm{gdy } \ U(k) \ge U^{\mathrm{max}}-U_{\mathrm{pp}}  \\
U(k) &\quad \textrm{w p.p.}
\end{cases}
\label{uk2}
\end{equation}

\begin{equation}
U(k) = U(k) + U_{\mathrm{pp}}
\label{upp}
\end{equation}

Symulacja cyfrowa algorytmu DMC odbywa się w oparciu o wzory (\ref{YYdUk}--\ref{dukdmc}).

\begin{equation}
\boldsymbol{Y}^{\mathrm{zad}}(k)=\left[
\begin{array}{c}
y^{\mathrm{zad}}(k)\\
\vdots\\
y^{\mathrm{zad}}(k)
\end{array}
\right] \
\boldsymbol{U}(k)=\left[
\begin{array}{c}
y(k)\\
\vdots\\
y(k)
\end{array}
\right] \
\triangle \boldsymbol{U}(k)=\left[
\begin{array}{c}
\triangle u(k|k)\\
\vdots\\
\triangle u(k+N_{\mathrm{u}}-1|k)
\end{array}
\right] \
\label{YYdUk}
\end{equation}

\begin{equation}
\triangle \boldsymbol{U}^{\mathrm{P}}(k)=\left[
\begin{array}{c}
\triangle u(k-1)\\
\vdots\\
\triangle u(k-(D-1))
\end{array}
\right]
\label{dUp}
\end{equation}

\begin{equation}
\boldsymbol{M}=\left[
\begin{array}
{cccc}
s_{1} & 0 & \ldots & 0\\
s_{2} & s_{1} & \ldots & 0\\
\vdots & \vdots & \ddots & \vdots\\
s_{N} & s_{N-1} & \ldots &  s_{N-N_{\mathrm{u}}+1}
\end{array}
\right]
\label{Marray}
\end{equation}

\begin{equation}
\boldsymbol{M}^{\mathrm{P}}=\left[
\begin{array}
{cccc}
s_{2} - s_{1} & s_{3} - s_{2} & \ldots & s_{\mathrm{D}} - s_{\mathrm{D-1}}\\
s_{3} - s_{1} & s_{4} - s_{2} & \ldots & s_{\mathrm{D+1}} - s_{\mathrm{D-1}}\\
\vdots & \vdots & \ddots & \vdots\\
s_{N+1} - s_{1} & s_{N+2} - s_{2} & \ldots & s_{\mathrm{N+D-1}} - s_{\mathrm{D-1}}\\
\end{array}
\right]
\label{MParray}
\end{equation}

\begin{equation}
\boldsymbol{Y}^{0}(k) = \boldsymbol{Y}(k) + \boldsymbol{M}^{\mathrm{P}} \triangle \boldsymbol{U}^{\mathrm{P}}(k)
\label{Y0k}
\end{equation}

\begin{equation}
\boldsymbol{K} = (\boldsymbol{M}^{\mathrm{T}} \boldsymbol{M} + \lambda \boldsymbol{I})^{-1} \boldsymbol{M}^{\mathrm{T}}
\label{Karray}
\end{equation}

\begin{equation}
\triangle \boldsymbol{U}(k) = \boldsymbol{K}(\boldsymbol{Y}^{\mathrm{zad}}(k) - \boldsymbol{Y}^{0}(k))
\label{dukdmc}
\end{equation}

Ponieważ w zadanym przypadku do regulacji wykorzystywane są jedynie sygnały z chwili $k$ liczenie ich w dalszych chwilach może być w tym przypadku pominięte. Dla przyspieszenia działania symulacji używany jest więc tylko pierwszy wiersz macierzy $\boldsymbol{K}$ oznaczony tutaj przez $\boldsymbol{K}_1$ - za jego pomocą liczona jest wartość sterowania jedynie w chwili aktualnej:

\begin{equation}
	\triangle u(k|k) = \boldsymbol{K}_1 (\boldsymbol{Y}^{\mathrm{zad}}(k) - \boldsymbol{Y}^{0}(k))
\end{equation}

\chapter{Podpunkt 5}

Tym samym parametry regulatora PID zostały dobrane na podstawie modelu (uzyskanego podczas aproksymacji) przy użyciu następującego fragmentu kodu:

\begin{lstlisting}[style=Matlab-editor]
s = tf('s');

sys = K/((s*T1+1)*(s*T2+1))*exp(-Td*s);
% wartości T1, T2 oraz Td otrzymano podczas optymalizacji
% parametrów modelu wykorzystanego przy aproksymacji

pidtune(sys,'PID');
\end{lstlisting} 

